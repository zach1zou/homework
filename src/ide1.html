<!--  <script type="text/javascript"> -->
    const _completeDeepClone = (target, map = new Map()) => {
        console.log(map);
        // if (target === null) return target // 如果是 null 就不进行拷贝操作
        // if (target instanceof Date) return new Date(target) // 处理日期
        // if (target instanceof RegExp) return new RegExp(target) // 处理正则
        // if (target instanceof HTMLElement) return target // 处理 DOM元素

        if (typeof target !== 'object') return target // 处理原始类型和函数 不需要深拷贝，直接返回

        // 是引用类型的话就要进行深拷贝
        if (map.get(target)) return map.get(target) // 当需要拷贝当前对象时，先去存储空间中找，如果有的话直接返回
        const cloneTarget = new target.constructor() // 创建一个新的克隆对象或克隆数组
        map.set(target, cloneTarget) // 如果存储空间中没有就存进 map 里

        Reflect.ownKeys(target).forEach(key => { // 引入 Reflect.ownKeys，处理 Symbol 作为键名的情况
            cloneTarget[key] = _completeDeepClone(target[key], map) // 递归拷贝每一层
        })
        return cloneTarget // 返回克隆的对象       
    }
    const obj = {
        a: true,
        b: 100,
        c: 'str',
        d: undefined,
        e: null,
        f: Symbol('f'),
        g: {
            g1: {} // 深层对象
        },
        h: [], // 数组
        i: new Date(), // Date
        j: /abc/, // 正则
        k: function () { }, // 函数
        l: [document.getElementById('foo')] // 引入 WeakMap 的意义，处理可能被清除的 DOM 元素
    }

    obj.obj = obj // 循环引用

    const name = Symbol('name')
    obj[name] = 'lin' // Symbol 作为键

    const newObj = _completeDeepClone(obj)

    console.log(newObj)
</script> -->
<!-- <script>
    function instance_of(L, R) { // L 表示左表达式，R 表示右表达式
        const O = R.prototype; //取右表达式的 prototype 值
        L = L.__proto__; // 取左表达式的__proto__值

        while (true) {
            if (L === null) { // Object.prototype 为 null
                return false
            }

            if (O === L) { // 当 O 严格等于 L 时，返回 true 
                return true
            }

            L = L.__proto__
        }
    }
</script> -->
<script>
    function fn() {
      console.log(this);
    }
    const obj = {
      name: "test",
      a() {
        console.log(this.a);
        setTimeout(function () {
          console.log(this.a);
        }, 1000);
      },
      b() {
        console.log(this);
        fn();
      },
    };
    obj.a();
    obj.b();
</script>